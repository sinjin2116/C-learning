---------------------------常量-----------------------------
#define 常量名 常量值 （定义宏常量）
const 类型 常量名 = 常量值 （const修饰的变量）
--------------------------sizeof-----------------------------
sizeof(类型||变量) （统计数据类型所占的内存大小）
sizeof(arr) (统计整个数组所占内存空间的大小)
sizeof(arr[0]) （统计某个元素所占内存空间的大小）
-----------------------C++字符型转整型--------------------
char c = '6'; //字符型 c = '6'
int num = c - '0'; //转换结果：num = 6
--------------------------转义字符--------------------------
\n： 换行
\t：水平制表（跳到下一个Tab位置）
\\：反斜线字符
--------------------------数组的定义方式-------------------
1 int arr[5];
2 int arr[5] = {10,20,30,40,50}; (如果输入不够用0填充)
cout<<arr<<endl; (输出数组的首地址)
--------------------------冒泡排序--------------------------
for (int i=0; i<nums.size()-1; i++) //外层排序次数 其实下面并没有用到这个变量，所以完全是用来计数的
	for (int j=0; j<nums.size()-1-i; j++)//内侧排序次数 这个遍历才是用来交换的
		if (nums[j]>nums[j+1]) swap();
	end;
end
--------------------------二维数组定义--------------------------
1 int arr[3][4]
2 int arr[3][4] = {{},{}};
3 int arr[3][4] = {1,2,3,4,5,6,7,8,9,0,12,11}
--------------------------获取二维数组行列大小----------------
lines = sizeof(arr) / sizeof(arr[0][0]); //整个数组的大小
row = sizeof(arr) / sizeof(arr[0]);
column = lines / row;
rows = arr.size();
columns = arr[0].size();
---------------------------值传递--------------------------------
形参变化不影响实参，地址传递会影响实参（所以函数在调用的时候，形参类型最好+const）
----------------------------函数声明------------------------------
在函数定义之前，告诉编译器有这个函数存在
----------------------------分文件编写---------------------------
1 创建.h头文件
2 创建.cpp源文件
3 头文件写申明
4 源文件写定义
5 关联头源文件
	1 在源文件中包含头文件（双引号）
	2 在头文件中包含iostream,using namespace std 
6 在主程序文件中再包含一下头文件
---------------------------空指针&野指针------------------------
空指针：指针变量指向内存中编号为0的空间（初始化指针变量，空指针的内存是不可访问的）
野指针：指针变量指向非法内存空间
----------------------------const修饰指针-------------------------（修饰谁谁可改）
1 修饰指针：const int * p = &a; (指向可改，值不可)
2 修饰值：int * const p = &a; (指向不可改，值可改)
----------------------------结构体----------------------------------
实例化：1 struct Student s1;(struct 可以省略)
	2 struct Student s2 = {...}
结构体放数组方便维护
实例化可以和数组一样：struct Student stuArray[3] = {{},{},{}};
		stuArray[2].name = 'jack'; (可以后期改)
结构体指针：实例化struct student s = {};
	struct student * p = &s;(其实也是跟指针一样，就是返回值类型不同)
-----------------------------内存分区---------------------------------
代码区：存放函数体的二进制代码，由操作系统管理
全局区（静态存储区）：全局变量和静态变量（普通局部变量前+static）以及常量(字符串常量和const修饰的全局变量（全局常量）)，结束后也由操作系统释放
栈区：编译器自动分配释放（一定是这个函数体结束，主函数也是一样！！！所以在主函数里的变量，在程序运行结束之前都不会被释放掉（即不会调用析构函数）），存放函参，局部变量(函数体内)，const修饰的局部变量（局部常量）
堆区：程序员分配释放，如果没释放，程序结束有操作系统回收
拓展：1 程序运行前，就已经进行了翻译操作，所以分为代码区和全局区
2 全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。
3 全局区会在程序刚开始完成唯一的一次初始化
4 静态变量的生存期为整个源程序，作用域和局部变量相同，函数退出时不能使用它
int fun()
{
    static int count = 10; // 在第一次进入这个函数的时候，变量 count 被初始化为 10 （只初始化一次）
    return count--; //以后每次进入该函数就不会被再次初始化了，count 的值是上一次函数运行之后的值  （如果不用static的话，每次调用局部变量count都是10，也就是每次都会先初始化）    
}
5 静态全局变量：也具有全局作用域，但被static关键字修饰过的变量具有文件作用域
6 静态函数（内部函数） ：在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
-----------------------------引用----------------------------------------------
如果函数的返回值是一个引用，那么该函数的调用可以作为左值，就是可以进行直接赋值（注意，这里函数体内的局部变量一定要加static放在全局区，不然局部变量在栈区，函数调用完会被操作系统自动释放，再次调用函数的时候会出错）
引用的本质：内部实现是一个指针常量（const修饰的常量）
常量引用：修饰形参，防止误操作（防止函数体内部修改实参）

--------------------------------new---------------------------------------
new出来的是一个地址，释放用delete p即可（但是释放数组的时候需要加[],,,delete[] arr;）
--------------------------------默认参数----------------------------------
1 如果没传就用默认，如果传了就用传的值
2 默认参数一般都放在含参的末尾，前一个有后面都得有默认参数
3 函数声明有默认参数，函数实现就不能有，不然会冲突
---------------------------------占位参数--------------------------------
1 只填数据类型
2 占位参数也可以有默认参数
----------------------------------重载---------------------------------------
函数名可以相同，提高复用性
满足条件：
1 同一个作用域（全局||局部）下
2 函数名相同
3 含参类型不同或者个数不同或者顺序不同
注意：返回值是不能作为函数重载的条件的
4 引用可以作为函数重载的条件
int &a = 10不合法，所以传入fun(10)的时候不走这个函数，而const int &a = 10 合法（相当于建了一个临时变量int temp = 10）所以不会出现二义性
----------------------------------------------------------------封装----------------------------------------------------------------------
1 将属性和行为作为一个整体，表现生活中的事务
2 将属性和行为加以权限控制
------------------------------------访问权限-------------------------------------------
1 public: 类内外都可以访问 
2 protected：类内可以，类外不行
3 private：类内可以，类外不行
2 3 区别主要在继承的时候体现，保护权限，父亲内容儿子类内可以访问，相反私有儿子也不能访问
拓展：1 struct默认权限为公共， class默认权限为私有
2 访问私有属性，可以在公共权限下设置私有属性的访问权限。
即，在公共权限下设置访问读写私有属性的接口（函数），比如说外部调用这个函数，传入的函参可以将私有属性进行赋值，从而修改私有属性的内容
------------------------------------对象初始化和清理（构造和析构）---------------------------
都在类里面写！！！！！！！！！！！！！！！！且作用域是public
构造函数语法：class_name(){} （析构函数就在前面多加一个~不可有参数，不可重载，对象在销毁前自动调用一次）
1 没有返回值也不写void
2 函数名称和类名相同
3 可以有参数，可以发生重载
4 程序在调用实例化的对象的时候会自动调用构造，无需手动调用，而且只会调用一次（只初始化一次）
这里就可以解释，（局部变量）建立在栈区的数据，在函数调用结束后会自动释放，这个释放的过程就是调用系统默认的析构函数（空实现）。所以构造函数就是用来初始化的，析构函数就是用来清理的
也可以在类外写成员函数或者构造函数，只不过要标记哪个类下的函数包括类内声明（Building();)：类外初始化：Building::Building（）{属性赋初值}表示Building下的构造函数（没有函数返回值）
-------------------------------------------构造函数-----------------------------------------------
有参，无参，普通
拷贝：class_name(const class_name &p){age = p.age}（一定是以引用的方式传进来而不是单纯的复制）
括号法：class_name p2(这里不加（），不然会被看作函数的申明), class_name p2(10),class_name p2(p1)
显示法：class_name p2 = classs_name(10), class_name p2 = classs_name(p1)
拓展：1 单纯的class_name(10)是一个匿名对象，当前行结束后系统会立即回收（构造之后马上析构）
2 不要用拷贝构造函数初始化一个匿名对象：class_name(p1) == class_name p1理解成实例化一个对象（重定义）
隐式转换法：class_name p4 = 10  ==  calss_name p4 = class_name (10),  class_name p5 = p4
-------------------拷贝构造的调用时机--------------------
1 使用一个已经创建完毕的对象来初始化一个新的对象
2 值传递
3 以值方式返回局部对象（返回的是一个新的对象）
-------------------深拷贝和浅拷贝-----------------------
浅拷贝：简单的赋值拷贝操作（带来的问题就是堆区的内存重复释放，因为两个构造函数都调用了，两个都要析构，而一个析构已经把开辟的空间释放掉了，另一个析构没有空间可以释放，所以会出错）
深拷贝：在堆区重新申请空间，进行拷贝
这里析构函数就有用了，将堆区开辟的数据释放
if (point != NULL){
	delete height;
	height = NULL;//防止野指针
}
深拷贝：
class_name(const class_name &p){
	age = p.age (不在堆区，会自动释放)
	height = new int (*p.height)
}
---------------------------------------------初始化列表-----------------------------------------------
这个也可以类外写
类中属性初始化
class_name(int a, int b): property1(a),property2(b)...{}
class_name p(10,20)就可以直接初始化赋值
--------------------------------------------静态成员--------------------------------------
-----------------------静态成员变量（也是有访问权限的）
1 所有对象共享同一份数据（内存中只有一份，所以改完会变，不属于某一个对象）
2 在编译阶段分配内存
3 类内声明，类外初始化
	类内声明：static int m_A;
	类外初始化：int class_name::m_A = 100;
拓展：1 静态成员变量不属于类的对象上的，非静态成员变量才属于
2 而非静态成员函数也不占用对象的空间，所以也是不属于类的对象上的（只需要有一份就可以了），因为非静态成员变量和非静态成员函数是分开存储的
---------------静态成员变量的访问---------------------
1 通过对象进行访问：其实没必要再创建一个对象了，因为它不属于某个对象，所以其实可以不用这个方式访问
2 通过类名进行访问：class_name::m_A就可以直接访问
------------------------静态成员函数
1 所有对象共享同一个函数
2 静态成员函数只能访问静态成员变量
----------------------------------------------this指针-------------------------------------------------------
解决静态函数的从属问题，到底是哪个对象调用我的这个函数
this指针指向的是被调用成员函数所属的对象，即p1调用成员函数了this就指向p1，谁调用指向谁！！！！！！！！！！！！！！！
用途：
1 形参和成员变量同名时可以用this区分
2 在类的非静态成员函数中返回对象本身，可以使用return *this（函数的返回类型class_name&引用的方式返回(主要是返回的是一个对象，最好不要用值传递，值传递调用拷贝构造返回的是一个新对象而不是原对象，所以必须以引用的方式传递)）
注意：this指针的本质是指针常量，所以指向是不可修改的，每个成员函数内部都有一个this指针
---------------------------------------------空指针调用成员函数--------------------------------------------
但是要注意函数体内部有没有用到this，如果碰到，需要判断代码的健壮性
注意：其实在调用成员属性的时候都会在属性前有个默认的this，所以在空指针调用成员函数的时候，this就指向了NULL，此时一个对象都没有，一个空的值要访问里面的属性是不可能的，所以会报错，此时可以在成员函数里加一句if (this==NULL) return 防崩
---------------------------------------------const修饰成员函数（常函数）----------------------------------
1 常函数内不可以修改成员属性
2 成员属性声明时加关键字mutable后，常函数依然可以修改
注意：这个const是放在函数（）的屁股后面（本质是const修饰this指针），加了之后成员属性的值就不可以修改了，因为this本身就是指针常量，加完就变成双限制，都不可以改
----------------------------------------------const修饰对象（常对象）--------------------------------------
常对象只能调用常函数
-------------------------------------------------友元-----------------------------------------------------------
目的就是让一个函数或者类，访问另一个类中私有成员（让对象进卧室而其他人不许进）
1 全局函数做友元：把这个全局函数的声明放在类内的最前面，再在开头加一个friend
2 类做友元：直接把类的申明复制进来，前面加一个friend
3 成员函数做友元：仍然是复制成员函数的声明，前面加一个friend，但是此时也要声明是哪个类下的成员函数，例子（friend void GoodGay::visiit();）
-----------------------------------------------------------------------------运算符重载--------------------------------------------------------------
自己写成员函数，实现两个对象相加后返回新的对象（全局函数也可以重载，只不过传入的参数调整一下即可）
正常编码：
Person PersonPlusPerson(Person &P){
	Person temp;
	temp.m_A = this.m_A+p.m_A;//（这里的this指向的.PersonPlusPerson前面那个东西，就是谁调用指向谁）
	temp.m_B = this.m_B+p.m_B;
	return temp;
}
运算符重载：（只要把上面的函数名改为通用的名称即可）
Person operator+(Person &P){
	Person temp;
	temp.m_A = this.m_A+p.m_A;//（这里的this指向的.PersonPlusPerson前面那个东西，就是谁调用指向谁）
	temp.m_B = this.m_B+p.m_B;
	return temp;
}
那么在调用这个函数的时候就应该Person p3 = p1.operator+(p2)----->简化为Person p3 = p1+p2 (p2为函参，p1为调用函数主体)
拓展：运算符重载也可以发生函数重载
------------------------------------------------------------------------左移运算符重载-----------------------------------------------------------
作用：可以输出自定义的数据类型（cout<<p<<endl;）(配合友元)
注意：通常不会通过成员函数重载左移运算符，因为成员函数调用一定是个类，如person，而左移运算符是cout作为函数名调用<<，所以不能用
全局函数重载：
ostream & operator<<(ostream &cout, Person &p){//本质是 operator<<(cout, p)---->简化：cout<<p 并且cout全局只能有一个，所以加引用
	cout<<"m_A = "<<p.m_A<<"m_B = "<<p.m_B;
	return cout;
}
--------------------------------------------------------------------递增运算符重载---------------------------------------------------------------
MyInteger& operator++(){//根本不需要参数，因为一直就是它自己（前置递增）
	m_Num++;
	return *this;
}
MyInteger operator++(int){//（后置递增）int代表占位参数，用于区分前置和后置递增。后置递增返回的是值（因为后置返回的是一个局部对象，如果返回引用，函数结束就被释放掉了还用个p啊）
	MyInteger temp = *this;//先记录结果
	m_Num++;
	return temp;
}
-------------------------------------------------------------------赋值运算符重载--------------------------------------------------------------
如果类中有属性指向堆区，做简单的赋值操作的时也会出现深浅拷贝的问题（有堆区的数据，一定要手动释放，只要写完析构，一定会崩掉，所以一定要用深拷贝，所以就不能简单的拷贝就行，这时候就要重载赋值运算符）
Person& operator=(Person &p){
	//要先判断是都有属性存放在堆区，如果有要先释放干净（因为之前视频有举例子，p2的属性有堆区数据）
	if (m_Age!=NULL){
		delete m_Age;
		m_Age = NULL;
	}
	//然后做深拷贝的工作
	m_Age = new int (*p.m_Age);//取出p下的指针再解引用拿到值之后new出来一个堆区存放这个值并将该新地址给到m_Age
	return *this;//this是一个指针，所以要解引用才是本体
}
----------------------------------------------------------函数调用运算符重载->（）-----------------------------------------------------------------
由于重载后的使用方式非常函数的调用，因此称为仿函数！！！！！！！！！！！！！！
仿函数没有固定写法，非常灵活
拓展一下匿名对象的写法：MyAdd()(100,100)其中MyAdd()是在创建一个匿名对象（特点，当前行执行完了立即释放）

----------------------------------------------------------继承----------------------------------------------------------------------------------
下级别的成员除了拥有上级别的共性，还有自己的特性----->采用继承的技术，减少重复的代码
语法：class 子类 ：继承方式 父类{}
把公共的部分抽离出来：
class BasePage{
public:
	...
}
子模块要继承上面的公共模块
class Java : public BasePage{
public:
	....个性化的东西
}
拓展：子类也叫做派生类，父类也称为基类

----------------------------------------继承方式（父类的私有属性都是无法访问的）---------------------------------------------
1 公共继承：父类的公共和保护属性在子类依然是公共和保护属性
2 保护继承：父类的公共和保护属性在子类都变为保护属性
3 私有继承：父类的公共和保护属性在子类都变为私有属性
-----------------------------------------继承中的对象模型-----------------------------------------
从父类继承过来的成员，到底属不属于子类的对象上面呢？哪些属于？
拓展：1 父类中所有的非静态成员属性都会被子类继承下去
2 父类中私有成员属性 是被编译器给隐藏了，所以访问不到，但是确实被继承下去了
3 利用开发人员命令提示工具可以查看对象模型（看看到底占多大的空间）
-----------------------------------------继承中构造和析构顺序------------------------------------
栈，先父后子，出先子后父
------------------------------------------继承中同名成员及成员函数的处理方式-------------------------------
访问子类同名成员（或者成员函数），直接访问即可
访问父类同名成员（或者成员函数），需要加作用域：s.Base::m_A  s.Base::func()
拓展：如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名的成员函数（包括函数重载的函数），所以要访问父类中的同名成员函数，必须要加作用域
-----------------------------------------继承者同名静态成员的处理方式-----------------------------------------
问题：继承中同名的静态成员在子类对象上如何进行访问
静态成员和非静态成员出现同名，处理方式一致
静态成员变量有什么特点呢？--->所有对象都共享同一份数据，编译阶段就分配内存，类内声明类外初始化（int Base::m_A = 100）
静态成员函数有什么特点呢？---->只能访问静态的成员变量，不能访问非静态的成员变量，只有一份，所有对象共享
成员变量和成员函数的访问方式依然是通过对象访问和通过类直接访问：
1 s.Base::m_A
2 Son::Base::m_A Son::Base::func()(第一个：：表示我要通过类名的形式访问数据，第二个：：表示父类作用域下的属性)

-----------------------------------------多继承语法--------------------------------------------------
class 子类 : 继承方式 父类1, 继承方式 父类2......
class Son : public Base1, public Base2{}
注意：多继承可能会引发父类中有同名成员出现，需要加作用域区分（在实际开发中不建议使用多继承）

------------------------------------------菱形继承（钻石继承）-----------------------------------------------------
概念：
1 两个派生类继承同一个基类
2 又有某个类同时继承两个派生类（其实这个类只需要一份数据就可以了，资源浪费）
怎么解决这个问题？------->虚继承！！！！！！！！！！！！！！！！！！！！！！
class Sheep : virtual public Animal {}
Animal类称为虚基类（共享一个数据，而且不会出现不明确的情况，即不需要加作用域也可以访问了）
虚继承底层？
两个派生类继承下来的编程了一个vbptr虚基类指针，指针指向一个vbtable虚基类表，这个表在对应类下。表中记录了一个数据偏移量，加上偏移量之后这个指针就指向了Animal类下的属性，所以这个属性现在只有一份


--------------------------------------------------------------------------多态--------------------------------------------------------------
静态多态：函数重载和运算符重载，复用函数名
动态多态：派生类和虚函数实现运行时多态
区别：静态多态函数地址早绑定（编译阶段），动态多态晚绑定（运行阶段）
当父类的引用在接收一个子类的对象---->Animal & animal = cat
在C++中，允许父子之间的转换，父类的引用可以直接指向子类的对象，但结果并不是，猫在说话，而是动物在说话，主要原因是复用函数名是地址早绑定，而派生类晚绑定，当前是animal的引用，在调用的时候，不论传什么动物，都会直接调用animal.speak函数。但是如果要执行猫在说话，那么这个函数的地址就不能提前绑定，需要在运行阶段进行绑定，也就是晚绑定。所以在speak函数前面加上virtual关键字，就可以实现，即虚函数！！！！！！！！！！！！！！！！（在父类的成员函数前面加virtual）
动态多态满足条件
1 有继承条件
2 子类要重写父类的虚函数
动态多态的使用
父类的指针或者引用来指向子类的对象--->void deSpeak(Animal &animal) 但是传入的是子类的对象

-------------------------------------多态的深入刨析----------------------------------------------
加上virtual之后父类的成员函数变成了一个虚函数指针vfptr，指针指向一个虚函数表vftable，表内部记录一个虚函数的地址，成员函数的函数地址需要加一个作用域&Animal::speak(这个就是虚函数的入口地址)。而子类（比如说猫类），在不发生重写的情况下就是个简单的继承关系，父类的指针也同样拿过来了一份，也有个vfptr指向一个vftable，表内也是个&Animal::speak函数的地址。但是如果现在发生了一个重写，子类会把子类里的虚函数表的内容做一个覆盖的操作，会替换成子类的虚函数地址&Cat::speak。当父类的指针后者引用指向子类的对象时，就发生了多态
Animal & animal = cat;
animal去调用speak函数的时候animal.speak 。由于指向的是cat对象，所以会从cat的虚函数表中去找speak函数，相当于在运行阶段发生了动态多态。即传的是哪个对象，就找哪个对象的虚函数表里的函数地址

---------------------------------------应用---------------------------------------------------------
AbstractCalculator * abc = new AddCalculator; new一个类相当于创建了一个子类的对象，这就就用父类的指针指向了子类的对象（创建在了堆区）（abc可以是父类指针，用父类指针调用各个子类的接口）
abc->m_Num1 = 10;
abc->m_Num2 = 20;
直接调用abc->getresult()，因为指向的是一个加法计算器，所以实现的是加法运算
假如不想要这个堆区的对象了，用完后记得销毁
delete abc; 只是把堆区的数据销毁掉了，数据的类型没有变，所以这里销毁数据完的时候指针还在，这就是为什么防止野指针出现的时候，不仅要销毁数据，还要把指针指向NULL
如果再想要用减法计算器
abc = new SubCalculator;

----------------------------------------------纯虚函数和抽象类-----------------------------------------
在多态中，父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数
virtual 返回值类型 函数名 （参考列表） = 0；
当类中有了纯虚函数，这个类也称为抽象类
抽象类特点：
1 无法实例化对象
2 子类必须重写抽象类的纯虚函数，否则也属于抽象类
多态学完了就可以理解多态了---->一个函数多种形态，即，根据子类的对象进行函数内容的不同的实现

-----------------------------------------------虚析构和纯虚析构-------------------------------------------
使用原因：多态使用中，如果子类中有属性开辟到堆区，父类指针在释放时无法调用到子类的析构代码（父类指针在delete的时候走不到子类的析构函数，造成内存泄漏）
内存泄漏的具体过程：new出来一个子类对象的时候，首先走的是父类的构造函数，然后子类的构造函数，然后应该是子类的析构，但是走不到，然后直接走到了父类的析构，所以造成内存泄露，这个产生原因就是我们用父类的指针指向子类的对象，所以在delete父类指针的时候并不会走子类的析构代码
解决方式：将父类中的析构函数改为虚析构或者纯虚析构
共性：可以解决父类指针释放子类对象。都需要有具体的函数实现！！！！！！！！！！
区别：纯虚析构属于抽象类，无法实例化对象
怎么把属性创建在堆区呢，是在构造函数里去new，并用一个指针去接收它，这个指针其实就是这个类的成员属性，只不过是指针
virtual ~Cat(){
	if (m_Name!=NULL){
		delete m_Name;
		m_Name = NULL;	
	}
}
纯虚析构的具体实现（类外）：
Animal::~Animal(){};(有了纯虚析构之后这个类也是属于抽象类了)

----------------------------------------------------------------------C++文件操作----------------------------------------------------------------
包含头文件<fstream>
ofstream: 写操作
ifstream: 读操作
fstream: 读写操作
-------------------------字符写文件：
1 创建流对象：ofstrean ofs // 内部有构造函数，所以也可以直接确定路径和打开方式
	ofstream ofs("文件路径"，打开方式);
2 打开文件：ofs.open("文件路径"，打开方式)
3 写数据：ofs<<"写入的数据"；
4 关闭文件：ofs.close()
打开方式（可以配合使用，用|操作符 ios::binary | ios::out）：
1 ios::in 为读文件打开
2 ios::out 为写文件打开
3 ios::ate	初始位置：文件尾
4 ios::app 追加方式写
4 ios::trunc 文件存在先删除，再创建
5 ios::binary 二进制方式
-------------------------字符读文件：
1 创建流对象：ifstream ifs
2 打开文件并判断文件是否打开成功：ifs.open("文件路径"，打开方式) if (!ifs.is_open()) {cout<<"失败"<<endl; return;}
3 读数据（四种方式）
	1 char buf[1024] = {0}; 创建一个字符数组，把文件的数据放进这个数组中
	   while (ifs>>buf) cout<<buf<<endl;
	2 char buff[1024] = {0}; 
	   while (ifs.getline(buff,sizeof(buf))) cout<<buf<<endl; 按照行读，第一个参数放数组的首地址char*，第二个就是数组所占的空间大小
	3 string buf;
	   while (getline(ifs,buf)) cout<<buf<<endl;
	4 char c;
	   while ((c = ifs.get) != EOF) cout<<c; 逐字符读，如果没有读到文件尾，就一直读
4 关闭文件：ifs.close()
------------------------二进制写文件：
打开方式要多加一句 ios::binary
函数原型：ostream& write(const char * buffer, int len) 字符指针buffer指向内存中一段存储空间，len是读写的字节数
写文件：Person p = ("张三", 18);
ofs.write((const char *)&p, sizeof(Person)); 这里用了强转指针
-------------------------二进制读文件：
函数原型：istream& read(char * buffer, int len);

-------------------------------------------------------------------模板（泛型编程）---------------------------------------------------------
建立一个通用函数，返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表
语法：1 template<typename T>  template：声明创建模板 typename：表明后面的符号是一种数据类型，可以用class代替
2 函数声明或定义
void mySwap(T &a, T &b){
	T temp = a;
	a = b;
	b = temp;
}
两种方式使用函数模板
1 自动类型推导
mySwap(a, b);
2 显示指定类型
mySwap<int>(a, b);

--------------------------------------普通函数和函数模板的调用规则--------------------------------------
1 如果都可以实现，优先调用普通函数
2 可以通过空模板参数列表来强制调用函数模板  mySwap<>(a, b)
3 函数模板也可以发生重载
4 如果函数模板可以产生更好的匹配，优先调用函数模板
注意：模板不是万能的，有些特定的数据类型，需要用具体化方式做特殊实现
解决方案一：运算符重载
解决方案二：利用具体化Person的版本实现代码，具体化优先调用
template<> bool myCompare (Person& p1, Person & p2){
	if (p1.m_Name==p2.m_Name && p1.m_Age==p2.m_Age) return true;
	else return false;
}

-------------------------------------------类模板---------------------------------------------------------
后面紧跟的类就是类模板
template<class NameType, class AgeType>
class Person{
public:
	Person(NameType name, AgeType age){
		this->m_Name = name;
		this->m_Age = age;
	}
	NameType m_Name;
	AgeType m_Age;
}
Person<string, int> p1("孙悟空", 999);

------------------------------------------类模板和函数模板的区别-----------------------------------------
1 类模板没有自动类型推导的使用方式
2 类模板在模板参数列表中可以有默认参数
template<class NameType, class AgeType = int>

------------------------------------------类模板中成员函数的创建时机------------------------------------
1 普通类中的成员函数一开始就创建了
2 类模板中的成员函数在调用时才创建

----------------------------------------类模板对象做函数参数--------------------------------------------
template<class T1, class T2>
class Person{
public:
	Person(T1 name, T2 age){
		this->m_Name = name;
		this->m_Age = age;
	}
	void showPerson(){
		cout<<"姓名："<<this->m_Name<<"年龄："<<this->m_Age<<endl;
	}
	T1 m_Name;
	T2 m_Age;
}
1 指定传入类型--直接显示对象的数据类型（这个比较常用）
void printPerson1(Person<string, int>&p){
	p.showPerson();
}
void test01(){
	Person<string, int>p("孙悟空", 999);
	printPerson1(p);
}
2 参数模板化   --将对象中的参数变为模板进行传递
template<class T1, class T2>
void printPerson2(Person<T1, T2>&p){
	p.showPerson();
	cout<<"T1的数据类型为："<<typeid(T1).name()<<endl;
}
void test02(){
	Person<string, int>p("猪八戒", 888)；
	printPerson2(p);
}
3 整个类模板化--将这个对象类型 模板化进行传递
template<class T>
void printPerson3(T &p){
	p.showPerson();
	cout<<"T的数据类型为："<<typeid(T).name()<<endl;
}
void test03(){
	Person<string, int>p("唐僧", 333)；
	printPerson3(p);
}

------------------------------------类模板与继承--------------------------------------------
1 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的数据类型
2 如果不指定，编译器无法给子类分配内存
3 如果想灵活指定出父类中T的数据类型，子类也需变为类模板
template<class T>
class Base{
	T m;
};
当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的数据类型
class Son1 : Public Base<int>{
		
}
void test01(){
	Son s1;
}
如果想灵活指定出父类中T的数据类型，子类也需变为类模板
template<class T1, class T2>
class Son2 : Public Base<T2>{
	T1 obj;	
}
void test02(){
	Son2<int , char> S2;
}

----------------------------------------------类模板成员函数的类外实现--------------------------------------------
构造函数类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age){
	this->m_Name = name;
	this->m_Age = age;
}
成员函数类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson(){
	cout<<"姓名："<<this->m_Name<<"年龄："<<this->m_Age<<endl;
}

------------------------------------------------模板分文件编写---------------------------------------------------
出现问题：类模板中成员函数的创建时机是在调用阶段，导致分文件编写的时候链接不到
解决方案：
1 直接包含.cpp文件
2 将声明和实现写到同一个文件中，并更改后缀名为.hpp（约定的名称，并不是强制，一看这个就知道是类模板）
具体做法：
1 创建.h和.cpp文件，在头文件里把一般的要包含的都包含上
2 把类内声明的类全部粘到头文件里
3 把类外实现全部粘在cpp文件里，并在cpp文件里，包含一下头文件
4 在主函数里也包含一下头文件
#解决的话就是主函数里的头文件.h改为,cpp（基本上不这样处理）
#常用的解决方式，放在一起之后直接包含这个hpp文件就可以了

----------------------------------------------------类模板和友元-----------------------------------------------
模板配合友元函数的类内类外实现
1 全局函数类内实现---直接在类内声明友元即可
template<class T1, class T2>
class Person{
	//全局函数类内实现
	friend void printPerson(Person<T1,T2> p){
		cout<<"姓名："<<p.m_Name<<"年龄："<<p.m_Age<<endl;
	}
public:
	Person(T1 name, T2 age){
		this->m_Name = name;
		this->m_Age = age;
	}
private:
	T1 m_Name;
	T2 m_Age;
};
//1 全局函数在类内实现的测试
void test01(){
	Person<string, int>P("Tom", 20);
	printPerson(P);	
}

2 全局函数类外实现---需要提前让编译器知道全局函数的存在
template<class T1, class T2>
class Person;
//类外实现（要放前面）
template<class T1, class T2>
void printPerson2(Person<T1,T2> p){
	cout<<"姓名："<<p.m_Name<<"年龄："<<p.m_Age<<endl;
}
template<class T1, class T2>
class Person{
	//全局函数类外实现
	//加一个空模板的参数列表
	//如果全局函数是类外实现，需要让编译器提前知道这个函数的存在
	friend void printPerson2<>(Person<T1,T2> p);
public:
	Person(T1 name, T2 age){
		this->m_Name = name;
		this->m_Age = age;
	}
private:
	T1 m_Name;
	T2 m_Age;
};
//2 全局函数在类外实现的测试
void test02(){
	Person<string, int>P("Jerry", 20);
	printPerson2(P);	
}

-------------------------------------------------------------------------STL-------------------------------------------------------------------
六大组件：容器，算法，迭代器（容器和算法的胶合剂），仿函数，适配器（修饰容器，仿函数或者迭代器的接口），空间配置器（空间的配置和管理）
注意：vector没有find函数，只有哈希表有，vector的迭代器需要std::find

-----------------------------string---------------------------
string是一个类，里面封装了char*指针，是一个char*型的容器
成员函数：
1 assign（赋值，也可以用=）: 
	string& assign(const char*s, int n) 把字符串s的前n个字符赋给当前的字符串
	string& assign(int n, char c) 用n个字符c赋给当前字符串
2 append（拼接，也可以用+=）：
	string& append(const char*s, int n) 那字符串s的前n个字符连接到当前字符串结尾
	string& append(const string&s, int pos, int n) 字符串s中从pos开始的前n个字符连接到当前字符串结尾（pos是下标，从0开始）	
3 find||rfind（查找）（没找到返回-1）：
	int find (const string& str, int pos = 0) const; 查找str第一次出现的位置，从0开始
	int find (const char*s, int pos, int n) const; 从pos位置查找s的前n个字符第一次位置
	int rfind (const string& str, int pos = npos) const; 查找str最后一次出现的位置，从pos开始
	int rfind (const char*s, int pos, int n) const; 从pos查找s的前n个字符最后一次位置
4 replace（替换）：
	string& repalce (int pos, int n, const string& str) 替换从pos开始n个字符为字符串str
5 compare（比较ASCII值）
6 字符存取，修改也可以用这种方式：
	[ ] 下标方式访问
	char& at(int n); at获取字符
7 insert（插入）：
	string& insert(int pos, const char*s) 插入字符串
	string& insert(int pos, int n, const char*s) 在指定位置插入n个字符串
8 erase（删除）：
	string& erase (int pos, int n = npos) 删除从pos开始的n个字符
9 substr （子串的获取）：
	string substr (int pos = 0, int n = npos) const; 返回由pos开始的n个字符组成的字符串
2 copy
3 delete
5 insert
string管理char*所分配的内存，不用担心赋值或者越界，由类内部进行负责

-------------------------------------vector-----------------------------------------
迭代器是支持随机访问的迭代器
常规用法：vector<int> :: iterator it = v.begin(); it != v.end(); it++ 
构造可以用 vector<int>v2(v1.begin(), v1.end())
v.rend(): 迭代器指向第一个位置前一个元素
v.rbegin: 迭代器指向最后一个元素
assign（赋值）：assign(beg, end) 将[begin,end)区间的数据拷贝赋值给本身
empty()：判断是否为空
capacity()：容量
resize(int num)：
insert(const_iterator pos, ele): 迭代器指定位置pos插入ele 
insert(const_iterator pos, int count, ele): 迭代器指定位置pos插入count个ele 
erase(const_iterator pos): 删除迭代器指向元素
erase(const_iterator start, const_iterator end): 删除迭代器从start到end之间的元素
clear()：删除所有元素
sort(beg, end)， 默认升序，如果要降序，需要写一个函数 bool cmp(int i, int j) {return (i < j);}
swap(): 连两个容器元素进行交换（巧用swap可以收缩内存空间！！！！！！！！！）
解释：一个很大的数据量在resize之后，容量不变，造成浪费。解决方式就是收缩 vector<int>(v).swap(v);
解释：vector<int>(v)表示的是匿名对象，相当于利用拷贝构造函数创建了一个匿名对象，然后用v的大小来初始化这个匿名对象大小，然后互换，匿名对象自动销毁
reserve(int len)：容器预留len个元素长度，预留位置不初始化，元素不可访问
解释：动态扩展是慢慢网上加的，每次都要开辟内存。如果一开始就预留了足够的空间，那就减少了动态扩展的次数。先找好这么大空间，一次性找好

--------------------------------------deque(双端数组)-------------------------------------------
内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据。中控器里记录的是缓冲区的地址。插入元素会比较快，但是访问元素就慢很多，因为还要找到下一段缓冲区的地址。deque像连续的内存空间，其实不是！！！！！
deque迭代器也是支持随机访问的，即跳跃访问
构造函数和vector一摸一样。如果不想更改deque里的数据，就是只读的状态，那么才当作形参传入时，可以加一个const，此时迭代器也要改为const_iterator。
赋值操作也和vector一摸一样
大小操作也和vector一摸一样，但是没有capacity的概念
insert(pos, beg, end)：在pos位置插入[beg,end)区间的数据，无返回值
sort也可以用

-------------------------------------List(链表)-------------------------------------------------------
存储方式不是连续的空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器
构造也有这种形式： list(beg, end)
size empty resize
push_back 
pop_back
push_front
pop_front
insert(pos, elm)
insert(pos, n, elem)
insert(pos, beg, end)
clear();
erase(beg, end)
erase(pos)
remove(elem) 删除所有与elem相匹配的元素
reverse成员函数  .reverse
sort成员函数  .sort
注意！所有不支持随机访问迭代器的容器， 不可以用标准算法如sort(beg,end)

----------------------------------------------------------set---------------------------------------
size
empty
swap
erase
find
insert
count：统计key元素个数
set容器也可以排序，利用仿函数，默认虽然是从小到大
创建的时候就要告诉它要从大到小排序！！！！
class cmp{
public:
	bool operator()(int v1, int v2){
		return v1>v2;
	}
}
set<int, cmp>s2即可

-------------------------------------------------------pair-----------------------------------------
pair<int, int>p(2,9)创建对组
------------------------------------------------------map-----------------------------------------
m.insert(pair<int, int>(2,4))
size
empty
swap
erase ：返回的是下一个元素的迭代器
clear
map排序也可以从大到小排，还是利用仿函数map<int,int,cmp>m

------------------------------------------------------------函数对象（仿函数）----------------------------------
class MyAdd{
public:
	int operator()(int v1, int v2){
		return v2+v2;
	}
}
使用：
MyAdd myadd; //myadd就是函数对象
myadd(4, 5) //直接像函数一样去使用即可

函数对线可以作为参数传递
void dePrint(MyPrint & mp, string test){
	mp(test);
}
doPrint(myprint, "Hello, C++")

-----------------------------------------------------------------谓词-------------------------------------------------
返回bool类型的仿函数

-------------------------------------------------------------stl内建的仿函数----------------------------------------
sort(vec.begin(), vec.end(), greater<int>()) 大到小排序，就可以不写那个仿函数了

-----------------------------------------------------------常用算法-----------------------------------------------
<algorithm><numeric><functional>
1 for_each(iterator beg, iterator end, _func) 遍历容器
2 transform(iterator beg1, iterator end1, iterator beg2, _func) 搬运容器到另一个容器中，目标容器需要提前开辟空间
3 find(iterator beg, iterator end, val)
4 find_if(iterator beg, iterator end, _Pred) 按条件查找元素
5 adjacent_find(iterator beg, iterator end) 查找相邻重复元素，找到了就返回第一个元素的迭代器  010314 3 3
6 binary_search(iterator beg, iterator end, val) 二分法查找 返回的是bool类型（无序序列不能用）
7 count(iterator beg, iterator end, val)	
8 count_if(iterator beg, iterator end, _Pred) 按条件统计元素个数


-------------------------------------------------------二叉树的构造-----------------------------------------------
struct TreeNode{
	int val;
	TreeNode * left;
	TreeNode * right;
	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};



























socket就是插座，程序之间通过socket建立起一个通道，数据可以传输
socket把复杂的TCP/IP协议族隐藏，只要用好socket相关函数，就可以实现网络通信
socket分类（两种通信机制）：
流（stream）：基于TCP协议，双向字节流
数据报（datagram）：基于UDP协议（不可靠但效率高）不需要建立和维持连接，可能数据会丢失和错乱
简单的socket通信流程：
客户端：					服务端
1 socket() 创建流式socket			1 socket() 创建流式socket
2 connet() 向服务器发起连接请求		2 bind() 指定用于通信的ip地址和端口
3 send()/recv() 发送/接收数据	-----------		3 listen() 把socket设为监听模式
4 close() 关闭socket连接，释放资源	-	4 accept() 接受客户端的连接
				-----------	5 recv()/send() 接收/发送数据
					6 close() 关闭socket连接，释放资源

客户/服务端模式（client/server）----->TCP/IP网络应用中，两个程序之间的通信模式
---------------------------------------linux基础，gdb调试------------------------------------------------


---------------------------------------------------------------------------------------------计算机网络--------------------------
TCP是面向连接的，连接建立->链接确认->请求对象->对象回来   需要两个往返时间（round trip time）
UDP，请求->对象回来 错了重传，用在事务性应用
应用层协议：通过两个主机报文的交互来实现各种各样的网络应用（远程的应用进程之间相互通讯应当遵守的规则和协议）
传输层：为多个远程的进程提供服务（传输层是在网络层端到端（主机）的服务基础上实现）（网络层基础之上加强服务，进程到进程）
网络层：源主机到目标主机以IP数据报为单位数据交互（尽力而为的，无保障），中间要经过很多跳，每一跳从一个网卡到相邻网卡，是通过网卡的数据链路层点到点（以帧为单位）的服务实现。
这种服务必须要到物理层，把数字的信号变成物理信号（光信号或者电磁波信号）。对方做相反变化，变成数字信号，交给对方的网络，然后IP分组取出交给上层
物理层：数字信号变成物理信号，借助物理介质传给相应网卡。介质处在第0层

网络层传统协议：在互联网的网络层分为两个协议：IP协议，路由协议
IP协议：使用路由表，来一个IP分组来，根据分组来决定（插三个网卡连三个网络，接收一个方向的分组，到底往剩下两个哪个方向走，下一跳是什么）即转发处理
路由协议：运行在路由之上的，路由器的软件称之为路由实体，和其他路由实体相互交换路由报文（即路由信息）（到哪个子网几跳，多少延迟，什么代价），最后按照某种路由选择算法来算出路由表（包括IP子网该怎么走）

弊端：升级根本不可能

更有弹性的工作方式：SDN（软件定义网络）
数据平面（交换机）：把流表上载，将多个字段拿过来匹配流表，根据流表所描述的行为冻住分组，行为不仅是转发，也可以是泛洪，也可以block掉，还可以改字段
控制平面（网络操作系统）：运行各种网络应用（算流表（包括源IP，目标IP等很多字段）），流表通过标准协议，南向接口发给交换机

比较，SDN 1 字段种类是不一样的，2 网络应用可以通过SDN运算形成各种流表，下发给交换机 3 交换机根据匹配的流表，动作是多样化的

-------------------------------------------------------正题---------------------------------------------------------
网络：节点和边的关系
计算机网络：联网的计算机所构成的系统（主机节点，数据交换节点（中转节点）），骨干链路(backbone)，接入链路（access)，还有协议
互联网：以TCP/IP协议为主的一小簇协议（为分布式应用提供通讯服务的基础设施（应用层以下及网络核心））

协议定义了在多个通信实体之间的报文格式和次序，以及动作（PDU（Protocol Data Unit）协议数据单元，一个报文格式的统称）的协议集合
协议控制发送、接收消息：如TCP,IP,HTTP,FTP,PPP(对等层实体所要遵守的规范)，规范了语法语义时序动作
Internet：网络的网络，互联的ISP
Internet标准：RFC（Request for comments）IETF(Internet Engineering Task Force)

对于网络来说，操作系统向应用进程提供通讯服务的api叫网络的api或者叫socket API，（形式，原语）

网络边缘（edge）：主机，应用程序（客户端和服务器）
网络核心（core）：路由器，网络的网络
接入网、物理媒体（access）: 有线或者无线通信链路

客户端-服务器模式容易崩，引出peertopeer模式。
p2p是一个分布式应用进程：每个节点既是客户端也是服务器

握手：在数据传输之前做好准备
基础设施提供的通讯服务分为两类：1 面向链接的通信方式 2 有连接
两个分布式进程要通讯：
面向连接的通信方式：首先要打个招呼，底层的协议栈为以后的两个应用进程之间通信准备好相应的资源，做好标记，准备缓冲区，控制变量置位，超时定时器要设置好等等，之后才通信

TCP提供特性：可靠的（不重，不丢，不错，不失序）。流量控制，拥塞控制

UDP（用户数据报协议）：无连接服务（不打招呼）

数据交换的方式：分组交换和线路交换（不适合计算机通信）
网络核心分组交换：链路之间每一跳使用带宽的全部。单位是包pocket，存储转发存储转发
分组交换的好处是共享，按需使用。代价是排队延迟和可能丢失
丢包：到达速率>链路的输出速率。如果路由器缓存用完了，分组将会被抛弃，或者TTL（IP头--生存时间）被减为0了
丢包重传：路由器重传，源主机重传，UDP（根本不重传）
吞吐量：在源端和目标端之间传输的速率（数据量/单位时间）

分组交换实际上是一种时分多路复用（划时间片）

分组交换网络分为
数据报网络：通信之前无须建立连接，有数据就传输。每一个分组都独立路由（路径不一样可能会失序）。路由器根据分组的目标地址进行路由
虚电路网络：通信之前建立虚电路（靠信令）

层次化方式实现复杂网络功能
1 下层为上次提供服务
2 本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上次提供更好的服务
3 实现本层协议的时候，直接利用了下层所提供服务

套接字就是socket API的SAP（服务访问点），三个用户申请，得到的报文数据到底给哪个用户
如要向客户端发送邮件：就需要通过层间的接口，通过socket API来向对方发送

数据单元（DU）的组成
SDU（Server Data Unit）   上层交给下层的数据，因为要穿过层间接口，肯定要加上一些控制信息（ICI（interface control information））------SDU+ICI =  IDU
拿到上层的SDU之后，本层需要加上一些控制信息（ICI头部），形成本层的PDU（协议数据单元）。上层的ICI不用管。

每一次的PDU不同
应用层：应用报文（Message）
传输层：报文段（segment）
网络层：分组packet，如果无连接方式称为IP数据报（datagram）
链路层：帧（Frame）
物理层：位（bit）

Internet协议栈（从上到下）
应用层：网络应用
---为人类用户或者其他应用进程提供网络应用服务
---FTP,SMTP,HTTP,DNS
传输层：主机之间的数据传输
---在网络层提供的端到端通信的基础上，细分为进程到进程，不可靠通信变为可靠通信
---TCP,UDP
网络层：为数据报从源到目的选择路由
---主机主机之间的通信，端到端通信，不可靠
---IP，路由协议
链路层：相邻网络节点间的数据传输
---2个相邻2点的通信，点到点通信，可靠或不可靠
---点对点协议PPP,802.11(wifi),Ethernet
物理层：在线路上传送bit

-----------------------------------------------------------------------导论结束-----------------------------------------------------------------------------------------
-----------------------------------------1 应用层----------------------------------------------------------
问题1 对进程进行编址
进程为了接收报文，必须有一个标识(SAP)，发送同样也需要标识
	主机：唯一的32位IP地址(因为有很多进程，并能定位到某个，所以仅有IP是不够的)
	所采用的传输层协议：TCP or UDP
	端口号（Port Numbers），任何一个进程都一个end point来标识，端口号就是用来区分应用进程的
	知名端口，web（HTTP）：TCP80，FTP：TCP21 || 2， Mail：TCP25
传递的SDU包括，谁传的（IP+TCP（UDP）端口），传给谁（IP+TCP（UDP）端口），以及要传输的报文
传输层实体根据上面的信息进行TCP报文段（UDP数据报）的封装

减少传输的信息量------------socket（就像是一个句柄，对句柄操作就相当于对文件操作）
TCP socket：源IP，源端口，目标IP，目标端口
TCP服务，两个进程之间的通信需要之前建立连接
可以用一个整数表示两个应用实体之间的通信关系，本地标示（人工引入的一个机制）
穿过层间接口的信息量最小
总的来说这个整数就代表了<源IP，源端口，目标IP，目标端口>，写也在可以表里，读也在这个表里，所以socket代表的是会话关系
UDP socket只是一个二元组，只有本地的ip和本地UDP端口，所以要传的东西就有三个货物本身，UDPsocket，对方IP对方端口
socket就是个传送门

传输层向应用层提供的服务：1 数据丢失率，2 延迟， 3 吞吐， 4 安全性
TCP和UDP都不提供安全性-------引出SSL
SSL在TCP上面实现，提供加密TCP连接
SSL：安全套接字层
SSL在应用层，应用采用SSL库，SSL库使用TCP通信
SSL socket API，应用通过API将明文交给socket，SSL将其加密后传输

Web 是一种应用，HTTP是支持web应用的协议
Web网页就是一个对象，对象下面又嵌了对象（链接），任何一个对象都可以通过URL（通用资源定位符）访问
HTTP：超文本传输协议（是一种无状态服务器，不用维护客户的任何信息）
建立连接之后，浏览器（HTTP客户端）与Web服务器（HTTP服务器server）交换HTTP报文（应用层协议报文）

维护状态的协议很复杂，如果服务器/客户端死机了，还要恢复历史信息
大多数主要门户网站使用cookies
1 在HTTP响应和请求报文中还有一个cookies的首部行
2 用户端系统保留一个cookies文件，由用户的浏览器管理
3 Web站点有一个后端数据库

使用Web缓存，web缓存既是客户端又是服务器
减少网络负担，降低需求响应时间

FTP（文件传输协议）
SMTP（简单邮件传输协议）
DNS（域名解析系统）域名->IP 给其他应用用的
CDN 解决视频并发？
动态自适应流化：DASH over HTTP(就是个传输协议)（客户端自适应决定码率）

socket套接字编程
1 服务器首先运行，创建socket，然后和本地端口绑定，在socket上阻塞式等待接收
2 创建客户端本地socket（隐式捆绑到本地port）
3 指定服务器进程的IP地址和端口号，与服务器进程连接
4 当客户端连接请求到来时，接收请求，解除阻塞式等待，返回一个新的socket（允许一个服务器与多个客户端通信，使用源IP和源端口来区分不同的客户端）

IP地址和port捆绑关系的结构体
struct sockaddr_in{
	short sin_family; //AF_INET----------------------sin_family 地址簇（常量，代表TCP/IP协议簇）
	u_short sin_port; //port--------------------------port 端口
	struct in_addr sin_addr;--------------------------sin_addr IP地址
		// IP address, unsigned long
	char sin_zero[8]; //align-------------------------sin_zero 对齐
};
域名和IP地址的结构体
struct hostent{
	char* h_name; //给一个指针，里面放主机的域名
	char** h_aliases; //指针的指针，二维的，主机的一系列别名
	int h_addrtype; 
	int h_length; //地址的长度
	char** h_addr_list; //IP列表
	#define h_addr h_arrt_list[0];
};作为调用域名解析函数时的参数，返回后，将IP地址拷贝到sockaddr_in的IP地址部分

welcomeSocket = Socket(); //API中第一个，建立一个socket，返回一个整数（假如是8888）这个时候端口号和IP都还没赋。括号里的参数用来指明是TCP还是UDP socket
bind(welcomeSocket, &sad); //sad就是第一个结构体
ConnectSocket = accept(welcomeSocket, &cad) //如果解除阻塞，consocket会返回一个新的值如（8899），这个socket就包括了本地和客户端的IP和port
	...
read(ConSocket, )
	...处理需求
write();
close();

ClientSocket = Socket(PF_INET,...); //假如返回的是2222
客户端不用bind，但是操作系统其实有一个隐含的bind，bind(ClientSocket, &cad)
Connect(ClientSocket, &sad...) //参数指明对方的IP和端口
	...建立之后
write(ClientSocket, content)
read(ClientSocket, )

例子：客户端（TCP）
/* client.c */
void main(int argc, char* argv[]){ //一个参数是服务器域名，第二个是服务器端口号，拓展argv[0]进程名字
	struct sockaddr_in sad; /structure to hold an IP address of server */我是一个客户端，我需要一个结构体来描述服务器守护的IP和端口号
	int clientSocket; /* socket descriptor */ 客户端socket就是一个整数
	struct hostent* ptrh; /* point to a host table entry */ 结构体指针
	
	char Sentence[128];
	char modefiedSentence[128];
	
	host = argv[1]; port = atoi(argv[2]); // 1 放的是服务器域名，2 放的是端口号，，，host是个字符串，没有定义，port是个整形的变量，atoi字符串转换整形

	clientSocket = socket(PF_INET, SOCK_STREAM, 0); //创建socket int类的地址簇，TCPsocket, PF指Protocol Family协议簇。 AF（Address Family）地址簇。INET（internet），SOCK_STREAM表示以流的形式传播，而不是数据报，流的形式就是TCP实现的，UDP的话是SOCK_DGRAMx
		memset((char*)&sad, 0, sizeof(sad)); /* clear sockaddr structure */ sad结构体所占的内存清零，sad清0
		sad.sin_family = AF_INET; /* set family to internet */ 赋地址簇
		sad.sin_port = htons((u_short)port); //强转无符号短整型，然后强转网络次序。htons将主机字节序转换为网络次序
		ptrh = gethostbyname(host); //输入的是一个域名，得到的是一个结构体指针，指针内容存放的就是IP地址
			/* Convert host name to IP ddress */
		memcpy(&sad.sin_addr, ptrh->h_addr, ptrh->h_length); //将IP地址拷贝到sad.sin_addr-------这里就把发送给服务器的socket整个打包好了
			
		conect(clientSocket, (struct sockaddr*)&sad, sizeof(sad));
					...建立连接之后
		gets(Sentence) //从标准输入设备当中输入用户输入的字符串
		n = write(clientSocket, Sentence, strlen(Sentence)+1) //通过socket值，把用户输入的字符串打走
			...
		n = read(clientSocket, modifiedSentence, sizeof(modifiedSentence))
		printf("FROM SERVER %s\n", modifiedSentence)
		close(clientSocket)
}
/* server.c */
void main(int argc, char* argv[]){ //一个参数是服务器域名，第二个是服务器端口号，拓展argv[0]进程名字
	struct sockaddr_in sad; /structure to hold an IP address of server */我作为服务器的本地端节点
	struct sockaddr_in cad; /* client */另外一个客户端进程结构体变量
	int welcomeSocket, connectSocket; /* socket descriptor */ 客户端socket就是一个整数
	struct hostent* ptrh; /* point to a host table entry */ 结构体指针
	
	char clientSentence[128];
	char capitalizedSentence[128];
	
	port = atoi(argv[1]); 

	welcomeSocket = socket(PF_INET, SOCK_STREAM, 0); //创建socket int类的地址簇，TCPsocket, PF指Protocol Family协议簇。 AF（Address Family）地址簇。INET（internet），SOCK_STREAM表示以流的形式传播，而不是数据报，流的形式就是TCP实现的
		memset((char*)&sad, 0, sizeof(sad)); /* clear sockaddr structure */ sad结构体所占的内存清零，sad清0
		sad.sin_family = AF_INET; /* set family to internet */ 赋地址簇
		sad.addr.s_addr = INADDR_ANY /* set the local IP address */INADDR_ANY 常量，代表本地任何一个IP地址
		sad.sin_port = htons((u_short)port); //强转无符号短整型，然后强转网络次序。htons将主机字节序转换为网络字节序
	bind(welcomeSocket , (struct sockaddr*)&sad, sizeof(sad));
	/* Specify the maximun number of clients that can be queued */
	listen( welcomeSocket, 10 ) //放一个队列，长度为10。如果我在服务的时候又来了请求，这个请求应该放在队列当中，下面循环完结束就从队列里拿一个。超过10个就拒绝

	while(1){
		connectionSocket = accept(welcomeSocket, (struct sockaddr*)&cad, &alen);
		n = read( connectionSocket, clientSentence, sizeof( clientSentence));
		/* capitalize Sentence and store the result in capitalizedSentence */
		
		n =  write( connectionSocket , capitalizedSentence, strlen( capitalizedSentence)+1) //通过socket值，把用户输入的字符串打走
		
		close( connectionSocket );
	}
}

------------------------------------------------------------------------传输层------------------------------------------------------------------------------------
多路复用/解复用
可靠的数据传输！！！！！（RDT）
流量控制（TCP实体对等层）
拥塞控制

传输层向应用进程提供逻辑通讯服务

UDP数据报的格式：1 源端口号，2 目标端口号，3 长度（包括报文），4 EDC（差错检测码，校验和。判断数据报包括头部和载荷的部分在传输的过程当中有没有出错，如果出错UDP就会被扔掉。如果通过校验，不一定就是对的，可能存在残存错误）5 报文（载荷）

RDT原理（网络TOP10question）
我要向上层提供可靠的服务，但是我依赖的服务（UDP）却不怎么可靠，怎么通过自身努力向上层提供可靠服务
rdt_send 被上层（如应用层）调用，以将数据交付给下方发送的实体（data），然后把data封装成packet，然后借助于发送方可靠传输实体跟下层的接口udp_send()往下发，下方的chennel是个不可靠的chennel。对方再通过udp_rcv()收到（也有可能收不到）这个packet，最后把这个packet中的data取出来，有序的正确的通过原语deliver_data()层间的接口交给接收方的进程

用有限状态机（FSM）来描述协议的机制(动作)

发送方：rdt_send(data) -> packet = make_pkt(data) -> udt_send(packet)
接收方：rdt_rcv(packet) -> extract(packet,data) -> deliver_data(data)

rdt2.0: 具有比特差错的信道
下层信道可能会出错：将分组中的比特翻转（用校验和来检测比特差错）
怎样从差错恢复？
确认（ACK）：接收方显示地告诉发送方分组已被正确接收
否定确认（NAK）：接收方显示地告诉发送方分组发生了差错-----------发送方收到NAK后，发送方重传分组
rdt2.0新机制：采用差错控制编码进行差错检测
发送方差错控制编码、缓存
接收方使用编码检错
接收方的反馈：控制报文（ACK, NAK）：接收方->发送方
发送方收到反馈相应动作
rdt2.1: 发送方处理出错的ACK/NAK
来了data封装packet序号是0，然后和checksum通过下方接口放出去，然后等待ACK/NAK，如果收到一个分组，分组是ACK而且没出错，就可以接着发送1号。如果发送方收到的是ACK或者收到NAK（到底是啥我不知道），分组本身是出错的，就重传packet0，有可能一直重复，但是可以通过序号校验出来（我在等1，结果你给我0，给个ACK，然后放出去，如果我在等待一，来一个分组然后出错了给NAK）
rdt2,2：NAKfree
只使用编了号的ACK
正确的情况：pkt0->ack0, pkt1->ack1, pkt0->ack0
错误的情况：pkt0->ack0, pkt1->ack0, pkt1->ack1
发送ACK0，当收到重复的ACK（如再次收到ACK0），发送方重传
一次能发多个分组
使用对前一个数据单位的ACK，代替NAK
确认信息减少一半，协议处理简单
rdt3.0: 具有比特差错和分组丢失的信道
超时重传！！！！！！！！（还有一个名词叫检错重传）
----------------------------------------------以上都是stop-wait协议（吞吐量的瓶颈不是在链路）（缺点，信道容量比较打的时候信道利用率比较低）
----------------------------------------------流水线（pipeline协议），提高利用率（吞吐量在于链路带宽）
1 GBN协议（退回N步）Go back N
2 SR协议（选择重传）selective repeat
通用：滑动窗口协议（slide window）
stop and wait ：发送方sw = 1, 接收方sw = 1
GBN：发送方sw > 1, 接收方rw = 1（顺序接收）
SR: 发送方sw>1, 接收方rw>1（可以乱序接收）(不具备累积确认的含义，为独立确认)
当sw>1----即流水线协议

发送缓冲区：内存中的一个区域，落入缓冲区的分组可以发送，用于存放已发送但没有得到确认的分组，重发时可用
发送缓冲区的大小决定一次可以发送多少个未经确认的分组
发送窗口：发送缓冲区的一个范围，发送窗口的最大值<=发送缓冲区的值。一开始没有发送任何一个分组，后沿=前沿，窗口尺寸为0，每发送一个分组，前沿前移一个单位。移动的极限不能超过发送缓冲区。在真实的场景中，发送缓冲区不动，分组后移（在收到反馈之后的分组）。为了便于学习，分组不动，窗口滑动。后沿极限为贴到前沿
同样有接收缓冲区和接收窗口：接收窗口 = 1，就一个个接，要接0，但是来的是1，说明是乱序，把1扔掉，继续等0。接到0，给个ACK0。如果接收窗口>1，就正常滑动了。所以接收窗口=1，顺序接收，>1可以乱序接收

-------------------------------------------------------TCP
MSS：最大报文段大小
TCP报文段结构：源端口，目标端口，32bit序号（报文第i个字节流占整个字节流的偏移量offset），32bit确认号（确认n-1及以前字节，即累积确认）（接收方对该字节及以后ACK号的期待），一些标志位（R S F是建立/拆除连接的标志位），接收窗口：用于流量控制，checksum（校验数据在传输过程有没有出错），报文
发送端发送报文，接收端接收并返回ACK555，发送方就知道对方已经收到了554及之前所有的字节，期望从555之后开始发送
自适应超时定时器策略
TCP的pipeline协议（是在IP不可靠的基础上建立了rdt）
发送方只设置一个定时器，一旦超时（超时时间设置为均值*四倍标准差），只把最老的段重传。接收方如果收到乱序的报文段，可以缓存也可以抛掉。
触发重传的事件
1 发送方超时----把最老的段发出去
2 发送方收到了某些段的三个冗余确认（但这个段还没有到超时），在定时器到时之前，收到三个冗余的ACK触发的重发，称为快速重传
接收方有个辅助定时器，500ms, 段到的话先不发ACK，到时间直接发n个段的累积确认（就是攒着）

流量控制：防止发送方发送太快，超过接收方的处理能力（可能缓冲区溢出）。所以是有一个反馈机制，反馈缓冲区剩余空间（buffer）大小给发送方（捎带技术（piggybacking））
捎带: 给到确认并同时把数据发送

2次握手会出现半连接的状态（克服的吊着服务器的资源，1 服务器维持了虚假连接）：连接请求超时，再收到确认之前，又发了一个连接请求，然后收到第一个连接请求的确认并发送数据，但是还没给确认，又重新发了一个数据，然后发送端结束了。这时对于服务器来说就是收到一个连接请求，然后给一个确认，之后呢又收到一个数据（2 这时候就把旧的数据当作新的数据来收了，伪造的数据）---------------其实就是建立连接的请求和数据都超时重发了，他们共同组成一个新连接的建立和数据部分

解决方案TCP 3次握手：连接请求，1 标志位SYN = 1（连接请求），2 sequenceNum = x告诉对方我要从x字节之后开始传（即x+1），之后服务器发送连接确认，1 SYN = 1，2 ACK = 1， 3 ACKnum = x+1, 你不是告诉我从x开始传吗，实际是从x+1开始传，4 同时我把我的序号给你squencenum = y。之后客户端收到第二次握手之后，我要确认你的初始序号，并发出第三次握手，1 ACK = 1， 2 ACKnum = y+1。然后连接才建立起来（第三次握手通常跟数据传递在一起）
互相把对方的初始序号进行确认，最少三次握手
如果第三次握手不成功，给服务器一个拒绝信息，服务器取消半连接
如果第三次握手发送的数据滞留在了网络里，然后在连接取消之后又流到了服务器，不会对服务器造成影响，因为没有连接，直接把数据扔掉就行。
还一种情况是我俩上一次很愉快，之后隔了一段时间之后客户端再次建立连接（相同端口），突然来一个老数据（滞留在网络），就是新数据，到了服务器（这时候就把老的连接数据当作新连接数据接收了），注意了！！！初始序号就起作用了，客户端从x需要开始，服务器从Y开始，所以并不是固定序号开始而是随机序号开始道理也在这。后面接收的序号范围跟我完全不在一个空间内部，数据就直接扔掉。

连接释放：两个方向单独拆除
客户端向服务器发送连接拆除，对方说好，然后就没有客户端到服务器的数据传递了，但是服务器到客户端的数据传递仍然有，如果对方也没有数据过来了，服务器也会发一个拆除请求，客户端给一个确认，从而服务器到客户端的数据传递也没了。整个连接拆除

------------------------------------拥塞控制
非正式定义：太多的数据需要网络传输，超过了网络的处理能力（依然是T10问题）
拥塞的表现：1 分组丢失（路由器缓冲区溢出）2 分组经历比较长的延迟（在路由器的队列里排队），流量强度 = 1就延迟巨大，越超时越重发，G了

端到端拥塞控制
网络辅助的拥塞控制

TCP拥塞控制
检测拥塞：1 超时，2 三个冗余ACK
如何控制发送端发送的速率 。
congwin(以字节为单位，在对方未确认的情况下可以往网络当中注入多少个字节)，然后除以往返延迟，就限制了单位时间往网络注入字节的数量。所以只要控制congwin就可以控制发送速率
congwin是动态的，如果段超时了，或者收到三个冗余ACK，整个拥塞控制的窗口要下降。如果两种情况外（正确收到对方的确认），未发生超时，增加拥塞控制窗口
超时情况：congwin将为1MSS，进入ss阶段然后再倍增到congwin/2(每个RTT)，从而进入CA阶段
三个重复ACK：congwin降为congwin/2，CA阶段
否则：
SS阶段：加倍增加（每个RTT）
CA阶段：线性增加（每个RTT）
联合控制的方法：发送端控制发送但是未确认的量同时也不能超过接收窗口，满足流量要求
sendWin = min(Congwin, RecvWin)

拥塞控制策略：
慢启动：TCP刚建立 congwin = 1MSS只能打一个段，每一个RTT，congwin加倍。每收到一个ACK，congwin+1，只要不超时或三个重复ACK，一个RTT，congwin加倍。。直到快要超时，在超时之前，当congwin变成上次发生超时的窗口的一半。实现变量：Threshold。出现丢失：Threshold设置成Congwin的1/2，进入慢启动阶段，慢启动阶段是折线，线性增，乘性减。
乘性减：丢失发生后将congwin降为1，将congwin/2作为阈值，进入慢启动阶段，倍增直到congwin/2
线性增：当congwin>Threshold，一个RTT如果没有发生丢失时间，将congwin加1MSS，这时候是拥塞避免阶段，窗口线性增长
当收到重复的ACK，Threshold设置成Congwin/2，congwin = Threshold+3，状态变为CA
当超时发生时，Threshold = congwin/2，congwin = 1MSS，进入SS阶段
超时事件后的保守策略：

----------------------------------------------------------------------网络层
-------------------------------数据平面（什么端口入，什么端口出，转发功能）
传统方式：基于目标地址+转发
SDN方式：基于多个字段+流表，多个动作，转发、阻止、泛洪、修改字段
-------------------------------控制平面（决定如何在路由器之间路由，从源网络到目标网络的路径，这里网络指的是子网，而不是主机，一个子网对应很多主机）
传统路由算法
SDN（software-defined networking）远程服务器中实现

------------------路由器组成
路由：运行路由选择算法，协议（RIP，OSPF，BGP）-生成路由表
转发：输入输出链路交换数据报--IP协议对到来的路由表进行分组转发。匹配目标IP
而SDN是匹配流表多个字段，按照表项的action（转发，block，泛洪，修改字段）对分组做动作。流表是网络操作系统上的网络应用算出，按照南向接口交给SDN交换机，交换机按照流表对到来的分组做多字段匹配，做多种动作。网络应用希望对分组做什么动作就下发什么样的流表。过程当中流表还可以变化，可以增删，所以网络可编程。所以在SDN模式下分组交换机对分组的动作就是可编程
路由器：物理层->数据链路层->网络层---------switch fabric--------网络层->数据链路层->物理层
网络层都有个queue(就是路由表缓冲区)，因为前后速度可能不一样
fabric的三种交换结构：
1 基于memory
2 基于bus
3 基于crossbar

------------------路由选择算法
输入：网络拓扑（某个节点泛洪获得），边的代价，源
输出：source到所有目标的最优路径是什么
-------最优化原则（optimality principle）
汇集树（sink tree）
此节点到所有其他节点的最优路径形成的树（最终形成了路由表）
路由选择算法就是为所有路由器找到并使用汇集树
1 链路状态算法link state routing（得到整网拓扑，再用dijstra算法算最短路径）：其实就是临时节点向源节点找最少代价路径，一直找到最后一个节点。在真实情况中，由于流量代价是浮动的，所以最终会出现震荡的情况
2 distance vector（距离矢量算法，基于dp的算法）。递归方程是Bellman-ford方程，本节点到邻居的代价+邻居到目标节点的代价和的最小值

实际中使用的路由选择协议（内部网关协议）
1 RIP通告（基于的是DV）：邻居之间定期交换通告报文
2 OSPF（开放最短路径优先，基于LS）：两个级别的层次性，本地、骨干。链路状态通告仅仅在本地Area进行，每一个节点拥有本地区域的拓扑信息。
	区域边界路由器：“汇总，聚集”到自己区域内网络的距离，向其他边界路由器通告
	骨干路由器：仅仅在骨干区域内运行OSPF路由
	边界路由器：连接其他AS‘s（自治区）

ISP之间的路由选择BGP（自治区域间路由协议事实上的标准，将互联网各个AS粘在一起的胶水）
BGP提供给每个AS以下方法：
1 eBGP：从相邻的ASes那里获得子网可达信息
2 iBGP：将获得的子网可达信息传遍到AS内部的所有路由器
3 根据子网可达信息和策略来决定到达子网的“好”路径
	本地偏好
	最短AS-PATH：AS跳数
	最近NEXT-HOP路由器：热土豆路由
	BGP标示
允许子网向互联网其他网络通告“我在这里”
基于距离矢量算法，不仅仅是距离矢量，还包括到达各个目标网络的详细路径，如AS序号的列表，能够避免简单的DV算法的路由环路问题

---------------------------------------------------链路层和局域网（包括物理层的内容）
差错检测：EDC（差错检测和纠正位）
CRC（循环冗余校验）！！！！
1 异或运算（模2运算） 2 位串的两种表示（1011，生成多项式表示） 3 生成多项式（r次方的bit序列） 4 约定：（D::EDC(r位)）发送方数据位后面附上r位的冗余位，使得数据位和冗余位正好能够被生成多项式整除。接收方检测，如果能整除，说明数据没问题，不能就出错

MAP多点访问协议：分布式算法，决定节点如何使用共享信道，即决定谁，什么时候可以使用这个信道发送
MAC（介质访问控制协议）：多点发送，电磁波冲突
TDMA（time division multiple access）轮流使用信道，分时间片
FDMA（frequency division multiple access）分频
CDMA（code division multiple access）编码原理区分，在整个频段上传输，码分
Random access（随机存取协议）：检测冲突并从冲突恢复（CSMA/CD，CSMA/CA）
WLAN：无线局域网（构成：AP基站，无线链路，移动主机节点）
CSMA（carrier sence multiple access）：加入监听信道，有人在发就不发，距离越长，冲突概率越大
CSMA/CD（以太网介质防控的方式，有线）用的是冲突检测：CS说之前听一听，CD边说边听，冲突停止。并发送强化冲突信号Jam，因为之前有衰减。失火了失火了！再尝试重发（二进制指数规避算法exponential backoff）
CSMA/CA（collision avoidance，WLAN中使用）用的是冲突避免：有基础设施的模式中，基站通过无线信道，无线主机通过无线链路接入AP，AP连到交换机，再接校园网或者互联网。 （依然监听信道，如果信道是忙的，不要等空了才发，而是选择一个随机值，选择小值的节点优先获得信道访问权）并在信道空闲时递减该值（count down）。当数到0时，发送整个帧，如果没有收到ACK，增加回退值。接收方如果帧正确，则在SIFS后发送ACK
Taking Turns（轮流MAC协议，令牌）（信道划分+随机访问）

IP地址是分层的：一个子网所有站点网络号一致，路由聚集，减少路由表。需要一个网络中的站点地址网络号一致，如果捆绑，需要定制网卡非常麻烦，所以希望网络层地址是配置的，IP地址完成网络到网络的交付
MAC地址是平面的：网卡在生产时不知道被用于哪个网络，因此给网卡一个唯一标识，用于区分一个网络内部不同的网卡，可以完成一个物理网络内部的节点到节点的数据交付（把分组封装成帧，从一个设备转到另一个设备）

拆分的好处：链路层有MAC地址，链路层上面除了IP协议外还可以支持其他的协议。封装在一起，一个网络就不可能支持多个协议，只能IP。第二个好处，网卡坏了，换个网卡，IP不变

补充：ARP协议（地址解析协议）
用于局域网通信（使用MAC地址而不是IP地址）
作用：二层寻址（寻找MAC地址）
为什么要寻址，设备更换IP地址都会导致IP和MAC地址对应关系的改变，所以需要ARP协议保证每次传输数据之前首先获取正确的目标设备MAC地址
作用范围：同一个广播域（同一组直接相连的不可管理交换机或者同一个VLAN）
每个终端设备上都有ARP表，用来记录IP地址和MAC地址对应关系，ARP表是有老化时间的，不同厂商的网络设备的操作系统老化时间不尽相同，2min-20min不等，老化时间到达之后就需要使用ARP协议来重新构建ARP表
ARP解析过程：
主机11想过去主机13的MAC地址
主机11广播一个ARP请求，请求中带上自己的IP和MAC地址，目标地址13，目标MAC地址全都是0.
主机13将自己的MAC地址放在ARP应答中，发送给主机11，这样两台主机就都有了彼此的MAC地址
特殊类型的ARP包---无故ARP
终端设备使用它来主动通告自己的MAC地址，也有来检测局域网有没有IP冲突，这也是操作系统会知道并且提示存在IP冲突的原因
寻址不是目的，目的是要传输数据
主机11要给主机13传输数据，因为目标地址和自己是同一广播域的，于是，主机11查询自己的ARP表，得到主机13的MAC地址，然后主机11对数据进行二层封装，将主机13的MAC地址填充帧头的目标地址字段，同时帧内还包括源地址，数据，FCS（校验码）。封装完成以后，11将帧从网卡发送出去，交换机检查MAC地址表，发现13的MAC地址对应的端口，于是将帧从端口发送出去，这就完成一次内网数据传输
ARP协议是无状态协议 （无法判别一个ARP应答是否是基于一个ARP请求而产生的）---黑客攻击，攻击者只要不停发送伪造的ARP应答就能导致受害者主机中毒，最终导致受害主机将数据全都发送到攻击主机上 

ARP协议和IP协议都在网络层
IP地址转化为MAC物理地址（固定在网卡）















